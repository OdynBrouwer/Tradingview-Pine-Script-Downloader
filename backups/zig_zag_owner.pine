// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © mupsje

//@version=6
library("Absolute_ZigZag_Lib_V1", overlay = true)


// @type The source to use
// @param high              (float) The high value for the pivot highs.
// @param low               (float) The low value for the pivot lows.
// @param priority          (string) Which source has higher priority ("high" or "low"). Default is "high"
export type Source 
    float  high     = high 
    float  low      = low
    string priority = "high"


// @type Features to enable
// @param closeBreaksClose  (bool)  Check if current (highest/lowest) pivot close broke previous pivot close.
// @param closeBreaksPivot  (bool)  Check if current (highest/lowest) pivot close broke previous pivot (high or low).
// @param ignoreInsideBars  (bool)  If true, inside bars are ignored for pivot calculation. The breakout logic compares against the last non-inside bar.
export type Features 
    bool closeBreaksClose = false 
    bool closeBreaksPivot = false
    bool ignoreInsideBars = false 


// @type Tooltips to show
// @param name              (bool)  Show the pivot's name in the tooltip?
// @param price             (bool)  Show the pivot's price in the tooltip?
// @param close             (bool)  Show the pivot's close price in the tooltip?
// @param volume            (bool)  Show the cumulative volume in the tooltip?
// @param closeBreaksClose  (bool)  Show if current (highest/lowest) pivot close broke previous pivot close (Only effective if feature is enabled).
// @param closeBreaksPivot  (bool)  Show if current (highest/lowest) pivot close broke previous pivot (high/low) (Only effective if feature is enabled).
export type Tooltips 
    bool name             = true
    bool price            = true 
    bool close            = true
    bool volume           = true
    bool closeBreaksClose = false 
    bool closeBreaksPivot = false


// @type Theme
// @desc Used to define a ZigZag theme with customizable styling options for lines, labels, and tooltips.
export type Theme
    bool     enabled       = false
    color    colorDefault  = color.gray
    color    colorNeutral  = color.yellow 
    color    colorBullish  = color.green 
    color    colorBearish  = color.red 
    int      lineWidth     = 2
    string   labelSize     = size.normal
    bool     showLabelL    = true
    bool     showLabelLL   = true
    bool     showLabelHL   = true
    bool     showLabelH    = true
    bool     showLabelLH   = true
    bool     showLabelHH   = true
    bool     coloredLines  = false 
    bool     showCloseInfo = false
    bool     showTooltips  = true 
    Tooltips tooltips


// @type All settings for the indicator
export type Settings 
    Source   source   
    Features features  
    Theme    theme 
    int      limit            


// @type Used to determine a coordination on the chart
export type Point 
    int   x    // time
    float y    // price


// @type Used to determine pivots on the chart.
export type Pivot 
    Point  point                            
    bool   isHigh                         
    bool   isHigher         = false     
    bool   hasPrev          = false   
    string name             = ""
    string abbr             = ""
    float  close            = close
    float  cumulativeVolume = 0.0  
    bool   closeBreaksPivot = false  
    bool   closeBreaksClose = false  
    bool   isLast           = true
    line   ln               = na 
    label  lb               = na 


// @function Gets the first Pivot
export method getFirst(array<Pivot> this) =>
    this.size() > 0 ? this.get(0) : na


// @function Gets the latest Pivot
export method getLast(array<Pivot> this) =>
    int size = this.size(), size > 0 ? this.get(size - 1) : na 


// @function Gets previous Pivot by index number.
export method getPrev(array<Pivot> this, int index = 1) =>
    int size = this.size(), size > index ? this.get(size - 1 - index) : na


// @function Checks if current pivot is higher than the previous paired pivot (2 back).
method isHigher(Pivot this, Pivot[] pivots) => 
    int size = pivots.size()
    if size > 2
        this.point.y > pivots.get(size - 3).point.y 
    else 
        false  


// @function Checks if the current pivot is at the current bar
export method isAtCurrentBar(Pivot this) =>
    this.point.x >= last_bar_time


// @function Checks if current pivot is a higher high
export method isHigherHigh(Pivot this) => 
    bool r = this.isHigh and this.isHigher


// @function Checks if current pivot is a lower high
export method isLowerHigh(Pivot this) =>
    bool r = this.isHigh and not this.isHigher


// @function Checks if current pivot is a higher low
export method isHigherLow(Pivot this) => 
    bool r = not this.isHigh and this.isHigher


// @function Checks if current pivot is a lower low
export method isLowerLow(Pivot this) =>
    bool r = not this.isHigh and not this.isHigher


// @function Gets the latest Pivot High based on previous number of Pivot highs back.
export method getHigh(array<Pivot> this, int prev = 1) => 
    int size = this.size()
    int n = math.max(1, prev)
    Pivot lastPivot = this.getLast()
    Pivot returnPivot = na
    if not na(lastPivot) 
        if n == 1 and lastPivot.isHigh 
            returnPivot := lastPivot 
        else 
            n := n * (lastPivot.isHigh ? 2 : 1)
            if size > n
                returnPivot := this.get(size - 1 - n)
    returnPivot


export method getLastHigh(array<Pivot> this) => this.getHigh(1)
export method getPrevHigh(array<Pivot> this) => this.getHigh(2)


// @function Gets the Pivot Low
export method getLow(array<Pivot> this, int prev = 1) => 
    int size = this.size()
    int n = math.max(1, prev)
    Pivot lastPivot = this.getLast()
    Pivot returnPivot = na
    if not na(lastPivot)
        if n == 1 and not lastPivot.isHigh 
            returnPivot := lastPivot 
        else 
            n := n * (lastPivot.isHigh ? 1 : 2)
            if size > n
                returnPivot := this.get(size - 1 - n)
    returnPivot


export method getLastLow(array<Pivot> this) => this.getLow(1)
export method getPrevLow(array<Pivot> this) => this.getLow(2)


// @function Builds name (and abbreviation) string for current pivot
method buildNameString(Pivot this) => 
    string highLowAbbr = this.isHigh ? "H" : "L"
    string highLow = highLowAbbr + (this.isHigh ? "igh" : "ow")
    string higherLowerAbbr = ""
    string higherLower = "" 
    
    if this.hasPrev
        higherLowerAbbr := this.isHigher ? "H" : "L"
        higherLower := higherLowerAbbr + (this.isHigher ? "igher " : "ower ")
        
    string name = str.format("{0}{1}", higherLower, highLow)
    string abbr = str.format("{0}{1}", higherLowerAbbr, highLowAbbr)
    [name, abbr]


// @function Builds the string for the CloseBreaksClose feature
method buildCloseBreaksCloseString(Pivot this) =>
    string str = this.closeBreaksClose ? (this.isHigh ? "꜀" : "ᶜ") : ""


// @function Builds the string for the CloseBreaksPivot feature
method buildCloseBreaksPivotString(Pivot this) =>
    string str = this.closeBreaksPivot ? (this.isHigh ? "ₚ" : "ᵖ") : ""


// @function Generates the text for the label of the Pivot
method buildLabelTextString(Pivot this, Settings settings) => 
    string str = ""
    if settings.theme.showCloseInfo 
        str := settings.features.closeBreaksClose ? this.buildCloseBreaksCloseString() : str 
        str += settings.features.closeBreaksPivot ? this.buildCloseBreaksPivotString() : ""
    
    if not this.hasPrev
        str := this.abbr 
    else 
        str := this.isHigh ? str + "\n" + this.abbr : this.abbr + "\n" + str 


// @function Creates a color based on current pivot conditions.
method generateColor(Pivot this, Pivot prev, Theme theme) =>
    color c = theme.colorDefault
    if this.isHigherLow()
        c := not prev.isHigher ? theme.colorNeutral : theme.colorBullish 
    if this.isLowerLow() 
        c := theme.colorBearish
    if this.isHigherHigh()
        c := theme.colorBullish
    if this.isLowerHigh()
        c := prev.isHigher ? theme.colorNeutral : theme.colorBearish
    c


// @function Checks if current close broke previous pivot value
method closeBrokePrevPivot(Pivot this) =>
    this.closeBreaksPivot


// @function Checks if current close broke previous pivot close
method closeBrokePrevPivotClose(Pivot this) =>
    this.closeBreaksClose


// @function Builds a tooltip string 
method buildTooltipString(Pivot this, Settings settings) => 
    array<string> tooltips = array.new<string>()

    string strName = this.name
    string strHighestOrLowest = this.isHigh ? "highest" : "lowest"

    if settings.theme.tooltips.name 
        tooltips.push("name\t\t\t: " + strName)
    if settings.theme.tooltips.price 
        tooltips.push("price\t\t\t: " + str.tostring(this.point.y))
    if settings.theme.tooltips.close 
        tooltips.push(strHighestOrLowest + " close\t\t: " + str.tostring(this.close)) 
    if settings.theme.tooltips.closeBreaksPivot 
        tooltips.push(str.format("close {0} pivot\t: {1}", this.isAtCurrentBar() or this.isLast ? "breaks" : "broke", this.closeBrokePrevPivot()))
    if settings.theme.tooltips.closeBreaksClose
        tooltips.push(str.format("close {0} close\t: {1}", this.isAtCurrentBar() or this.isLast ? "breaks" : "broke", this.closeBrokePrevPivotClose()))
    if settings.theme.tooltips.volume
        tooltips.push("volume\t\t\t: " + str.tostring(this.cumulativeVolume, format.volume))

    string str = array.join(tooltips, "\n")


// @function Adds a new pivot to the pivots array.
export method add(array<Pivot> this, Point point, bool isHigh, Settings settings) =>
    Theme theme = settings.theme 
    Pivot lastPivot = this.getLast() 
    Pivot prevPivot = this.getPrev()
    Pivot pivot = Pivot.new(point, isHigh)
    
    pivot.cumulativeVolume := volume
    float prevClose = nz(close[1], close)
    pivot.close := (isHigh ? math.max(close, prevClose) : math.min(close, prevClose))
    pivot.close := (isHigh and close > pivot.close) or (not isHigh and close < pivot.close) ? close : pivot.close

    if not na(lastPivot)
        color pivotColor = pivot.generateColor(lastPivot, theme)

        if not na(prevPivot)
            pivot.closeBreaksPivot := pivot.isHigh ? close > prevPivot.point.y : close < prevPivot.point.y
            pivot.closeBreaksClose := pivot.isHigh ? close > prevPivot.close : close < prevPivot.close
            
            pivot.isHigher := point.y > prevPivot.point.y
            pivot.hasPrev := true

            [name, abbr] = pivot.buildNameString()
            pivot.name := name 
            pivot.abbr := abbr 

            pivotColor := pivot.generateColor(lastPivot, theme)

            if theme.enabled 
                pivot.ln := line.new(
                  x1     = lastPivot.point.x, 
                  y1     = lastPivot.point.y, 
                  x2     = pivot.point.x, 
                  y2     = pivot.point.y, 
                  xloc   = xloc.bar_time, 
                  extend = extend.none, 
                  color  = theme.coloredLines ? pivotColor : theme.colorDefault, 
                  style  = line.style_solid, 
                  width  = theme.lineWidth)

        if theme.enabled 
            pivot.lb := label.new(
              x           = pivot.point.x,
              y           = pivot.point.y,
              text        = pivot.buildLabelTextString(settings), 
              xloc        = xloc.bar_time,
              yloc        = isHigh ? yloc.abovebar : yloc.belowbar,
              color       = color.rgb(0, 0, 0, 100),
              style       = label.style_none,
              textcolor   = (pivot.abbr == "L" and theme.showLabelL) or (pivot.abbr == "LL" and theme.showLabelLL) or (pivot.abbr == "HL" and theme.showLabelHL) or (pivot.abbr == "H" and theme.showLabelH) or (pivot.abbr == "LH" and theme.showLabelLH) or (pivot.abbr == "HH" and theme.showLabelHH) ? pivotColor : #00000000,
              size        = theme.labelSize,
              textalign   = text.align_center,
              text_font_family = font.family_default,
              tooltip     = theme.showTooltips ? pivot.buildTooltipString(settings) : "")
          
        lastPivot.isLast := false
        this.set(this.size() - 1, lastPivot)

    if this.size() >= settings.limit 
        Pivot oldestPivot = this.shift()
        oldestPivot.ln.delete()
        oldestPivot.lb.delete()
        oldestPivot := this.first()
        oldestPivot.ln.delete()

    this.push(pivot)
    pivot


// @function Updates pivot in array
method update(array<Pivot> this, Pivot pivot, Point point, Settings settings) =>    
    Theme theme = settings.theme   
    Pivot prevPivot = na
    pivot.point.x := point.x 
    pivot.point.y := point.y
    pivot.ln.set_xy2(point.x, point.y)
    pivot.lb.set_xy(point.x, point.y)
    
    float prevClose = nz(close[1], close)
    pivot.close := (pivot.isHigh ? math.max(close, prevClose) : math.min(close, prevClose))
    pivot.cumulativeVolume := pivot.cumulativeVolume + volume

    if not na(this) 
        prevPivot := this.getPrev(2)
        pivot.close := (pivot.isHigh and close > pivot.close) or (not pivot.isHigh and close < pivot.close) ? close : pivot.close

        if not na(prevPivot)
            Pivot lastPivot = this.getLast()
            pivot.isHigher := point.y > prevPivot.point.y
            pivot.hasPrev := true
            
            pivot.closeBreaksPivot := pivot.isHigh ? close > prevPivot.point.y : close < prevPivot.point.y
            pivot.closeBreaksClose := pivot.isHigh ? close > prevPivot.close : close < prevPivot.close

            [name, abbr] = pivot.buildNameString()
            pivot.name := name 
            pivot.abbr := abbr
            
            if theme.enabled
                color pivotColor = pivot.generateColor(lastPivot, theme) 
                color lineColor = pivotColor
                pivotColor := (pivot.abbr == "L" and theme.showLabelL) or (pivot.abbr == "LL" and theme.showLabelLL) or (pivot.abbr == "HL" and theme.showLabelHL) or (pivot.abbr == "H" and theme.showLabelH) or (pivot.abbr == "LH" and theme.showLabelLH) or (pivot.abbr == "HH" and theme.showLabelHH) ? pivotColor : #00000000
                pivot.lb.set_text(pivot.buildLabelTextString(settings))
                pivot.lb.set_textcolor(pivotColor) 
                if theme.showTooltips
                    pivot.lb.set_tooltip(pivot.buildTooltipString(settings))
                pivot.ln.set_color(theme.coloredLines ? lineColor : theme.colorDefault)
           
        this.set(this.size() - 1, pivot)
    pivot
  

// @function Scans for new pivot
method scan(array<Pivot> this, float source, bool isHigh, Settings settings) =>
    Point point = Point.new(time, source)
    Pivot lastPivot = this.getLast()
    if not na(lastPivot)
        if lastPivot.isHigh 
            if point.y >= lastPivot.point.y 
                this.update(lastPivot, point, settings)
            if not isHigh
                this.add(point, isHigh, settings)
        else 
            if point.y <= lastPivot.point.y
                this.update(lastPivot, point, settings)
            if isHigh
                this.add(point, isHigh, settings)
    else 
        this.add(point, isHigh, settings)


// @function Checks if the current bar is the latest pivot.
// @param this      (array<Pivot>)  The object to work with.
// @return          (bool)          True if the current bar matches the latest pivot's time.
export method barIsPivot(array<Pivot> this) =>
    Pivot lastPivot = this.getLast()
    not na(lastPivot) and lastPivot.point.x == time


// @function Creates a new ZigZag Instance
export new(Settings customSettings) =>
    Settings settings = customSettings

    if na(settings.source) 
        settings.source := Source.new()
    if na(settings.theme)
        settings.theme := Theme.new() 
    if na(settings.features)
        settings.features := Features.new()

    if settings.features.closeBreaksClose == false
        settings.theme.tooltips.closeBreaksClose := false
    if settings.features.closeBreaksPivot == false
        settings.theme.tooltips.closeBreaksPivot := false
    
    var Pivot[] pivots = array.new<Pivot>()
    float srcLow  = settings.source.low
    float srcHigh = settings.source.high

    var float stateHigh = srcHigh
    var float stateLow  = srcLow

    float prevHigh = settings.features.ignoreInsideBars ? stateHigh : nz(srcHigh[1], srcHigh)
    float prevLow  = settings.features.ignoreInsideBars ? stateLow  : nz(srcLow[1], srcLow)

    bool isInside = srcHigh <= prevHigh and srcLow >= prevLow
    bool process = not settings.features.ignoreInsideBars or not isInside

    if process
        bool isOutside = srcHigh > prevHigh and srcLow < prevLow
        bool isHigher  = srcHigh > prevHigh
        bool isLower   = srcLow  < prevLow

        if srcHigh != srcLow and isOutside
            if settings.source.priority == "high" 
                pivots.scan(srcHigh, true, settings)  
                pivots.scan(srcLow, false, settings)  
            else  
                pivots.scan(srcLow, false, settings)  
                pivots.scan(srcHigh, true, settings)  
        else
            if isHigher  
                pivots.scan(srcHigh, true, settings) 
            if isLower 
                pivots.scan(srcLow, false, settings) 

        if settings.features.ignoreInsideBars
            stateHigh := srcHigh
            stateLow  := srcLow

    pivots


export getLowerTimeframePeriod() =>
    int tf = timeframe.in_seconds(timeframe.period) 
    string ltf = switch true
        tf <= 60 => '10S'
        tf <= 300 => '1'       
        tf <= 600 => '2'       
        tf <= 1800 => '3'      
        tf <= 3600 => '5'      
        tf <= 14400 => '15'    
        tf <= 86400 => '30'    
        tf <= 172800 => '60'   
        tf <= 259200 => '240'  
        tf <= 432000 => '360'  
        tf <= 604800 => '720'  
        tf <= 1209600 => 'D'   
        tf <= 2628000 => '2D'  
        tf <= 5256000 => '5D'  
        tf <= 7884000 => 'W'   
        tf <= 15768000 => '2W' 
        tf <= 31536000 => '1M' 
        => timeframe.period


// =====================================================================================================================
// UTILITY FUNCTIONS
// =====================================================================================================================

// @function Formats a Unix timestamp (milliseconds) to a time string (HH:MM:SS)
// @param unixTime  (int)    The Unix timestamp in milliseconds
// @param utcOffset (int)    UTC offset in hours (default 0)
// @return          (string) Formatted time string "HH:MM:SS"
export formatTime(int unixTime, int utcOffset = 0) =>
    int timestamp = unixTime / 1000
    int offsetSeconds = utcOffset * 3600
    int adjustedTime = timestamp + offsetSeconds
    int hrs = math.floor(adjustedTime / 3600) % 24
    int mins = math.floor((adjustedTime % 3600) / 60)
    int secs = math.floor(adjustedTime % 60)
    str.format("{0}:{1}:{2}", 
         str.tostring(hrs, "00"), 
         str.tostring(mins, "00"),
         str.tostring(secs, "00"))


// @function Formats a Unix timestamp to a date string (YYYY-MM-DD)
// @param unixTime  (int)    The Unix timestamp in milliseconds
// @return          (string) Formatted date string "YYYY-MM-DD"
export formatDate(int unixTime) =>
    str.format_time(unixTime, "yyyy-MM-dd", syminfo.timezone)


// @function Formats a Unix timestamp to a full datetime string
// @param unixTime  (int)    The Unix timestamp in milliseconds
// @return          (string) Formatted datetime string "YYYY-MM-DD HH:MM"
export formatDateTime(int unixTime) =>
    str.format_time(unixTime, "yyyy-MM-dd HH:mm", syminfo.timezone)


// @function Creates a matrix from the last N pivots for data analysis/export
// @param this      (array<Pivot>) The pivots array
// @param rows      (int)          Number of pivots to include (default 5)
// @return          (matrix<float>) 8-column matrix: [timestamp, price, isHigh, isHigher, close, volume, closeBreaksPivot, closeBreaksClose]
export method toMatrix(array<Pivot> this, int rows = 5) =>
    matrix<float> m = matrix.new<float>(rows, 8, na)
    int size = this.size()
    
    if size >= rows
        for i = 0 to rows - 1
            Pivot p = this.getPrev(i)
            if not na(p)
                float timestamp = float(p.point.x / 1000)
                matrix.set(m, i, 0, timestamp)
                matrix.set(m, i, 1, p.point.y)
                matrix.set(m, i, 2, p.isHigh ? 1.0 : 0.0)
                matrix.set(m, i, 3, p.isHigher ? 1.0 : 0.0)
                matrix.set(m, i, 4, p.close)
                matrix.set(m, i, 5, p.cumulativeVolume)
                matrix.set(m, i, 6, p.closeBreaksPivot ? 1.0 : 0.0)
                matrix.set(m, i, 7, p.closeBreaksClose ? 1.0 : 0.0)
    m


// @function Gets the bar_index from a time value (useful for HTF pivots)
// @param barTime   (int)    The time in milliseconds
// @return          (int)    The corresponding bar_index
export getBarIndexFromTime(int barTime) =>
    int barIdx = 0
    int i = 0
    while i < bar_index
        if time[i] < barTime
            barIdx := bar_index - (i - 1)
            break
        i += 1
    barIdx


// @function Checks if a pivot has been broken by price in between (for liquidity detection)
// @param this      (Pivot)  The pivot to check
// @return          (bool)   True if the pivot was broken by intermediate bars
export method isBrokenByBar(Pivot this) =>
    bool broken = false
    int pivotBarIdx = getBarIndexFromTime(this.point.x)
    int barsBack = bar_index - pivotBarIdx
    
    if barsBack > 1
        for i = 1 to barsBack - 1
            if this.isHigh
                if low[i] > this.point.y
                    broken := true
                    break
            else
                if high[i] < this.point.y
                    broken := true
                    break
    broken


// =====================================================================================================================
// LIVE PIVOT TYPE (moved up so exported functions can use it)
// =====================================================================================================================
// @type Live pivot prediction result
// @param abbr      (string) The predicted abbreviation (HH, HL, LH, LL, H, L)
// @param name      (string) The predicted full name
// @param isHigh    (bool)   Whether the prediction is for a high pivot
// @param isHigher  (bool)   Whether it would be higher than previous paired pivot
// @param clr       (color)  The color based on current theme
// @param price     (float)  The predicted price level
// @param isOutsideBar (bool) True if current bar is an outside bar (creates 2 pivots)
// @param abbr2     (string) Second pivot abbreviation (only for outside bars)
// @param price2    (float)  Second pivot price (only for outside bars)
// @param clr2      (color)  Second pivot color (only for outside bars)
// @param isHigh2   (bool)   Whether second pivot is a high
export type LivePivot
    string abbr        = ""
    string name        = ""
    bool   isHigh      = false
    bool   isHigher    = false
    color  clr         = color.gray
    float  price       = na
    bool   isOutsideBar = false
    string abbr2       = ""
    float  price2      = na
    color  clr2        = color.gray
    bool   isHigh2     = false
    label  lb          = na
    label  lb2         = na


// @function Gets the pivot sequence as a string (e.g., "Live,HH,HL,LH,LL")
// @param this      (array<Pivot>) The pivots array
// @param length    (int)          Number of pivots to include (default 5)
// @param live      (LivePivot)    Optional live pivot to include at the start
// @return          (string)       Comma-separated pivot abbreviations
export method getSequence(array<Pivot> this, int length = 5, LivePivot live = na) =>
    array<string> seq = array.new<string>()

    // Include live pivot(s) first (if provided)
    if not na(live) and live.abbr != ""
        seq.push(live.abbr)
        if live.isOutsideBar and live.abbr2 != ""
            seq.push(live.abbr2)

    int already = seq.size()
    int remaining = math.max(0, length - already)
    int n = math.min(remaining, this.size())

    for i = 0 to n - 1
        Pivot p = this.getPrev(i)
        if not na(p) and p.abbr != ""
            seq.push(p.abbr)

    array.join(seq, ",")


// @function Checks if the current pivot sequence matches a pattern
// @param this      (array<Pivot>) The pivots array  
// @param pattern   (string)       Pattern to match (e.g., "HH,HL,LL,LH")
// @param live      (LivePivot)    Optional live pivot to include in sequence
// @return          (bool)         True if sequence starts with pattern
export method matchesPattern(array<Pivot> this, string pattern, LivePivot live = na) =>
    if pattern == ""
        false
    else
        string cleanPattern = str.replace_all(pattern, " ", "")
        cleanPattern := str.upper(cleanPattern)
        string sequence = this.getSequence(10, live)
        str.startswith(sequence, cleanPattern)


// @function Centers text with padding (for table formatting)
// @param txt       (string) The text to center
// @param width     (int)    Total width
// @return          (string) Padded centered string
export padCenter(string txt, int width) =>
    int spaces = math.max(0, width - str.length(txt))
    int leftPad = math.floor(spaces / 2)
    int rightPad = spaces - leftPad
    str.repeat(" ", leftPad) + txt + str.repeat(" ", rightPad)


// =====================================================================================================================
// LIVE PIVOT PREDICTION FUNCTIONS
// =====================================================================================================================



// @type Settings for Live Pivot Label visualization
// @param visible    (bool)   Show the live pivot label
// @param offset     (int)    Offset in bars to the right
// @param size       (string) Label size (size.tiny, size.small, size.normal, size.large, size.huge)
// @param showPrice  (bool)   Show price in label text
// @param showTrend  (bool)   Show trend arrow in label
export type LivePivotSettings
    bool   visible   = true
    int    offset    = 3
    string size      = na
    bool   showPrice = false
    bool   showTrend = false


// @type Settings for Live Pivot Table visualization
// @param visible    (bool)   Show the table
// @param position   (string) Table position (position.bottom_right, etc.)
// @param size       (string) Text size
// @param rows       (int)    Number of historical rows to show
// @param headerBg   (color)  Header background color
// @param tableBg    (color)  Table background color
export type LiveTableSettings
    bool   visible   = true
    string position  = na
    string size      = na
    int    rows      = 5
    color  headerBg  = na
    color  tableBg   = na


// @type Settings for Current Price Line
// @param visible    (bool)   Show the line
// @param clr        (color)  Line color
// @param width      (int)    Line width
// @param style      (string) Line style ("Solid", "Dashed", "Dotted")
export type CurrentLineSettings
    bool   visible = true
    color  clr     = na
    int    width   = 1
    string style   = "Dashed"


// @function Predicts what the next pivot would be if the current bar closes at current price
// @param this      (array<Pivot>) The pivots array
// @param existing  (LivePivot)    Existing LivePivot to update (preserves label references), or na for new
// @param srcHigh   (float)        Current high price (or custom source)
// @param srcLow    (float)        Current low price (or custom source)
// @param theme     (Theme)        Theme for color calculation
// @param priority  (string)       Priority for outside bars: "high" or "low" (default "high")
// @return          (LivePivot)    The predicted pivot information
export method predictLivePivot(array<Pivot> this, LivePivot existing, float srcHigh, float srcLow, Theme theme, string priority = "high") =>
    // Preserve label references from existing LivePivot
    LivePivot result = LivePivot.new()
    if not na(existing)
        result.lb := existing.lb
        result.lb2 := existing.lb2
    
    Pivot lastPivot = this.getLast()
    Pivot prevPivot = this.getPrev()
    
    if not na(lastPivot)
        // Get the last HIGH and last LOW pivots for comparison
        Pivot lastHighPivot = this.getLastHigh()
        Pivot lastLowPivot = this.getLastLow()
        
        // The NEXT pivot is always the OPPOSITE of the last pivot
        // If last was HIGH → next will be LOW (question: HL or LL?)
        // If last was LOW → next will be HIGH (question: HH or LH?)
        
        if lastPivot.isHigh
            // Last pivot is HIGH → Next pivot will be LOW
            result.isHigh := false
            result.price := srcLow
            
            // Compare to the PREVIOUS LOW pivot to determine HL vs LL
            if not na(lastLowPivot)
                result.isHigher := srcLow > lastLowPivot.point.y
                result.abbr := result.isHigher ? "HL" : "LL"
                result.name := result.isHigher ? "Higher Low" : "Lower Low"
                
                // Color based on context
                if result.isHigher
                    // HL after HIGH
                    result.clr := lastPivot.isHigher ? theme.colorBullish : theme.colorNeutral
                else
                    // LL
                    result.clr := theme.colorBearish
            else
                result.abbr := "L"
                result.name := "Low"
                result.clr := theme.colorDefault
        else
            // Last pivot is LOW → Next pivot will be HIGH
            result.isHigh := true
            result.price := srcHigh
            
            // Compare to the PREVIOUS HIGH pivot to determine HH vs LH
            if not na(lastHighPivot)
                result.isHigher := srcHigh > lastHighPivot.point.y
                result.abbr := result.isHigher ? "HH" : "LH"
                result.name := result.isHigher ? "Higher High" : "Lower High"
                
                // Color based on context
                if result.isHigher
                    // HH
                    result.clr := theme.colorBullish
                else
                    // LH after LOW
                    result.clr := lastPivot.isHigher ? theme.colorNeutral : theme.colorBearish
            else
                result.abbr := "H"
                result.name := "High"
                result.clr := theme.colorDefault
        
        // Outside bar detection (both high breaks AND low breaks)
        float prevHigh = nz(srcHigh[1], srcHigh)
        float prevLow = nz(srcLow[1], srcLow)
        bool isOutside = srcHigh > prevHigh and srcLow < prevLow
        result.isOutsideBar := isOutside
        
        if isOutside
            // For outside bars, we need to show both pivots
            if priority == "high"
                // High processes first, then low
                // So first pivot is based on current lastPivot
                if lastPivot.isHigh
                    // Update HIGH, then add LOW
                    result.isHigh := true
                    result.price := srcHigh
                    result.isHigher := not na(lastHighPivot) ? srcHigh > lastHighPivot.point.y : false
                    result.abbr := result.isHigher ? "HH" : "LH"
                    result.name := result.isHigher ? "Higher High" : "Lower High"
                    result.clr := result.isHigher ? theme.colorBullish : theme.colorBearish
                    
                    // Second pivot is LOW
                    result.isHigh2 := false
                    result.price2 := srcLow
                    bool isHigher2 = not na(lastLowPivot) ? srcLow > lastLowPivot.point.y : false
                    result.abbr2 := isHigher2 ? "HL" : "LL"
                    result.clr2 := isHigher2 ? theme.colorBullish : theme.colorBearish
                else
                    // Add HIGH (new), then continue with low
                    result.isHigh := true
                    result.price := srcHigh
                    result.isHigher := not na(lastHighPivot) ? srcHigh > lastHighPivot.point.y : false
                    result.abbr := result.isHigher ? "HH" : "LH"
                    result.clr := result.isHigher ? theme.colorBullish : theme.colorBearish
                    
                    // Second: update LOW
                    result.isHigh2 := false
                    result.price2 := srcLow
                    bool isHigher2 = not na(lastLowPivot) ? srcLow > lastLowPivot.point.y : false
                    result.abbr2 := isHigher2 ? "HL" : "LL"
                    result.clr2 := isHigher2 ? theme.colorBullish : theme.colorBearish
            else
                // Low processes first, then high
                if not lastPivot.isHigh
                    // Update LOW, then add HIGH
                    result.isHigh := false
                    result.price := srcLow
                    result.isHigher := not na(lastLowPivot) ? srcLow > lastLowPivot.point.y : false
                    result.abbr := result.isHigher ? "HL" : "LL"
                    result.clr := result.isHigher ? theme.colorBullish : theme.colorBearish
                    
                    // Second pivot is HIGH
                    result.isHigh2 := true
                    result.price2 := srcHigh
                    bool isHigher2 = not na(lastHighPivot) ? srcHigh > lastHighPivot.point.y : false
                    result.abbr2 := isHigher2 ? "HH" : "LH"
                    result.clr2 := isHigher2 ? theme.colorBullish : theme.colorBearish
                else
                    // Add LOW (new), then continue with high
                    result.isHigh := false
                    result.price := srcLow
                    result.isHigher := not na(lastLowPivot) ? srcLow > lastLowPivot.point.y : false
                    result.abbr := result.isHigher ? "HL" : "LL"
                    result.clr := result.isHigher ? theme.colorBullish : theme.colorBearish
                    
                    // Second: update HIGH
                    result.isHigh2 := true
                    result.price2 := srcHigh
                    bool isHigher2 = not na(lastHighPivot) ? srcHigh > lastHighPivot.point.y : false
                    result.abbr2 := isHigher2 ? "HH" : "LH"
                    result.clr2 := isHigher2 ? theme.colorBullish : theme.colorBearish
    
    result


// @function Gets the current trend direction based on last pivot
// @param this      (array<Pivot>) The pivots array
// @param currentPrice (float)    Current price to compare
// @return          (int)         1 = bullish (price above last pivot), -1 = bearish, 0 = neutral
export method getTrend(array<Pivot> this, float currentPrice) =>
    Pivot lastPivot = this.getLast()
    int trend = 0
    
    if not na(lastPivot)
        if currentPrice > lastPivot.point.y
            trend := 1
        else if currentPrice < lastPivot.point.y
            trend := -1
    
    trend


// @function Gets a string representation of the trend
// @param this      (array<Pivot>) The pivots array
// @param currentPrice (float)    Current price
// @return          (string)      "Bullish", "Bearish", or "Neutral"
export method getTrendString(array<Pivot> this, float currentPrice) =>
    int trend = this.getTrend(currentPrice)
    switch trend
        1  => "Bullish"
        -1 => "Bearish"
        => "Neutral"


// @function Checks if price is currently breaking the last pivot
// @param this      (array<Pivot>) The pivots array  
// @param currentPrice (float)    Current price
// @return          (bool)        True if price is breaking the last pivot
export method isBreakingLastPivot(array<Pivot> this, float currentPrice) =>
    Pivot lastPivot = this.getLast()
    bool breaking = false
    
    if not na(lastPivot)
        if lastPivot.isHigh
            breaking := currentPrice > lastPivot.point.y
        else
            breaking := currentPrice < lastPivot.point.y
    
    breaking


// @function Gets distance from current price to last pivot (in price and percentage)
// @param this      (array<Pivot>) The pivots array
// @param currentPrice (float)    Current price
// @return          (float)       Distance in price units
// @return          (float)       Distance as percentage
export method getDistanceToLastPivot(array<Pivot> this, float currentPrice) =>
    Pivot lastPivot = this.getLast()
    float distance = 0.0
    float percentage = 0.0
    
    if not na(lastPivot)
        distance := currentPrice - lastPivot.point.y
        percentage := (distance / lastPivot.point.y) * 100
    
    [distance, percentage]


// =====================================================================================================================
// VISUALIZATION EXPORT METHODS
// =====================================================================================================================

// @function Builds tooltip string for LivePivot label
// @param live          (LivePivot) The live pivot prediction
// @param currentPrice  (float)     Current close price
// @param trend         (int)       Trend direction (1=bullish, -1=bearish, 0=neutral)
// @param breaking      (bool)      Whether price is breaking the last pivot
// @param isSecondPivot (bool)      Whether this is for the second pivot (outside bars)
// @return              (string)    Formatted tooltip string
export method buildTooltip(LivePivot this, float currentPrice, int trend, bool breaking, bool isSecondPivot = false) =>
    array<string> tips = array.new<string>()
    
    string pivotName = isSecondPivot ? (this.isHigh2 ? (this.price2 > 0 ? "Higher " : "Lower ") + "High" : (this.price2 > 0 ? "Higher " : "Lower ") + "Low") : this.name
    float pivotPrice = isSecondPivot ? this.price2 : this.price
    
    tips.push("name\t\t\t: " + pivotName + " (LIVE)")
    tips.push("price\t\t\t: " + str.tostring(pivotPrice, format.mintick))
    tips.push("current close\t\t: " + str.tostring(currentPrice, format.mintick))
    tips.push("trend\t\t\t: " + (trend == 1 ? "Bullish ▲" : trend == -1 ? "Bearish ▼" : "Neutral"))
    tips.push("breaks pivot\t\t: " + str.tostring(breaking))
    if this.isOutsideBar
        tips.push("outside bar\t\t: true")
        tips.push("sequence\t\t: " + this.abbr + " @ " + str.tostring(this.price, format.mintick) + " → " + this.abbr2 + " @ " + str.tostring(this.price2, format.mintick))
    
    array.join(tips, "\n")


// @function Draws or updates the Live Pivot prediction label
// @param this      (array<Pivot>)       The pivots array
// @param live      (LivePivot)          The live pivot (will store label references)
// @param settings  (LivePivotSettings)  Display settings
// @return          (LivePivot)          Updated LivePivot with label references
export method drawLivePivotLabel(array<Pivot> this, LivePivot live, LivePivotSettings settings) =>
    if barstate.islast and settings.visible and this.size() > 0
        int trend = this.getTrend(close)
        bool breaking = this.isBreakingLastPivot(close)
        
        if live.isOutsideBar
            // Outside bar: show both pivots - position at current close
            float labelY1 = close
            float labelY2 = close
            
            string labelText1 = live.abbr + " →"
            string labelText2 = live.abbr2
            string tooltip1 = live.buildTooltip(close, trend, breaking, false)
            string tooltip2 = live.buildTooltip(close, trend, breaking, true)
            
            if na(live.lb)
                live.lb := label.new(
                     x = bar_index + settings.offset,
                     y = labelY1,
                     text = labelText1,
                     style = label.style_none,
                     color = #00000000,
                     textcolor = live.clr,
                     size = settings.size,
                     tooltip = tooltip1)
            else
                live.lb.set_xy(bar_index + settings.offset, labelY1)
                live.lb.set_text(labelText1)
                live.lb.set_style(label.style_none)
                live.lb.set_textcolor(live.clr)
                live.lb.set_tooltip(tooltip1)
            
            if na(live.lb2)
                live.lb2 := label.new(
                     x = bar_index + settings.offset + 2,
                     y = labelY2,
                     text = labelText2,
                     style = label.style_none,
                     color = #00000000,
                     textcolor = live.clr2,
                     size = settings.size,
                     tooltip = tooltip2)
            else
                live.lb2.set_xy(bar_index + settings.offset + 2, labelY2)
                live.lb2.set_text(labelText2)
                live.lb2.set_style(label.style_none)
                live.lb2.set_textcolor(live.clr2)
                live.lb2.set_tooltip(tooltip2)
        else
            // Normal single pivot - position at current close
            float labelY = close
            string labelText = live.abbr
            string tooltip = live.buildTooltip(close, trend, breaking, false)
            
            if na(live.lb)
                live.lb := label.new(
                     x = bar_index + settings.offset,
                     y = labelY,
                     text = labelText,
                     style = label.style_none,
                     color = #00000000,
                     textcolor = live.clr,
                     size = settings.size,
                     tooltip = tooltip)
            else
                live.lb.set_xy(bar_index + settings.offset, labelY)
                live.lb.set_text(labelText)
                live.lb.set_style(label.style_none)
                live.lb.set_textcolor(live.clr)
                live.lb.set_tooltip(tooltip)
            
            // Hide second label when not outside bar
            if not na(live.lb2)
                live.lb2.set_text("")
                live.lb2.set_textcolor(#00000000)
    
    live


// @function Draws or updates the current price line from last pivot to current bar
// @param this      (array<Pivot>)        The pivots array
// @param settings  (CurrentLineSettings) Display settings
// @param ln        (line)                Existing line reference (or na)
// @return          (line)                Updated line reference
export method drawCurrentPriceLine(array<Pivot> this, CurrentLineSettings settings, line ln) =>
    line result = ln
    
    if barstate.islast and settings.visible
        Pivot lastPivot = this.getLast()
        if not na(lastPivot)
            var lineStyle = line.style_dashed
            if settings.style == "Solid"
                lineStyle := line.style_solid
            else if settings.style == "Dotted"
                lineStyle := line.style_dotted
            else
                lineStyle := line.style_dashed
            
            if na(result)
                result := line.new(
                     x1 = lastPivot.point.x,
                     y1 = lastPivot.point.y,
                     x2 = time,
                     y2 = close,
                     xloc = xloc.bar_time,
                     color = settings.clr,
                     style = lineStyle,
                     width = settings.width)
            else
                result.set_xy1(lastPivot.point.x, lastPivot.point.y)
                result.set_xy2(time, close)
    
    result


// @function Draws or updates the Live Pivot Table
// @param this          (array<Pivot>)      The pivots array
// @param live          (LivePivot)         The live pivot prediction
// @param tableSettings (LiveTableSettings) Table display settings
// @param theme         (Theme)             Theme for colors
// @param tbl           (table)             Existing table reference (or na)
// @return              (table)             Updated table reference
export method drawLivePivotTable(array<Pivot> this, LivePivot live, LiveTableSettings tableSettings, Theme theme, table tbl) =>
    table result = tbl
    
    if barstate.islast and tableSettings.visible
        // Initialize table if needed
        if na(result)
            result := table.new(
                 position = tableSettings.position,
                 columns = 7,
                 rows = tableSettings.rows + 2,
                 bgcolor = tableSettings.tableBg,
                 border_width = 1,
                 border_color = color.gray)
            
            // Headers
            table.cell(result, 0, 0, "#",       bgcolor = tableSettings.headerBg, text_color = color.white, text_size = tableSettings.size)
            table.cell(result, 1, 0, "Time",    bgcolor = tableSettings.headerBg, text_color = color.white, text_size = tableSettings.size)
            table.cell(result, 2, 0, "Price",   bgcolor = tableSettings.headerBg, text_color = color.white, text_size = tableSettings.size)
            table.cell(result, 3, 0, "Type",    bgcolor = tableSettings.headerBg, text_color = color.white, text_size = tableSettings.size)
            table.cell(result, 4, 0, "Trend",   bgcolor = tableSettings.headerBg, text_color = color.white, text_size = tableSettings.size)
            table.cell(result, 5, 0, "Volume",  bgcolor = tableSettings.headerBg, text_color = color.white, text_size = tableSettings.size)
            table.cell(result, 6, 0, "Status",  bgcolor = tableSettings.headerBg, text_color = color.white, text_size = tableSettings.size)
        
        // Row 0: LIVE
        if this.size() > 0
            int trend = this.getTrend(close)
            bool breaking = this.isBreakingLastPivot(close)
            
            string typeText = live.isOutsideBar ? (live.abbr + "→" + live.abbr2) : live.abbr
            string statusText = live.isOutsideBar ? "OUTSIDE" : (breaking ? "BREAK!" : "idle")
            color statusColor = live.isOutsideBar ? color.orange : (breaking ? color.yellow : color.gray)
            
            table.cell(result, 0, 1, "LIVE",    text_color = color.yellow, text_size = tableSettings.size)
            table.cell(result, 1, 1, formatTime(time, 1), text_color = color.white, text_size = tableSettings.size)
            table.cell(result, 2, 1, str.tostring(live.price, format.mintick), text_color = color.white, text_size = tableSettings.size)
            table.cell(result, 3, 1, typeText, text_color = live.clr, text_size = tableSettings.size)
            table.cell(result, 4, 1, trend == 1 ? "▲" : trend == -1 ? "▼" : "─", 
                 text_color = trend == 1 ? theme.colorBullish : trend == -1 ? theme.colorBearish : theme.colorNeutral, 
                 text_size = tableSettings.size)
            table.cell(result, 5, 1, str.tostring(volume, format.volume), text_color = color.white, text_size = tableSettings.size)
            table.cell(result, 6, 1, statusText, text_color = statusColor, text_size = tableSettings.size)
        
        // Historical pivots
        for i = 0 to math.min(tableSettings.rows - 1, this.size() - 1)
            Pivot p = this.getPrev(i)
            if not na(p)
                Pivot prev = this.getPrev(i + 1)
                color pColor = not na(prev) ? p.generateColor(prev, theme) : theme.colorDefault
                
                table.cell(result, 0, i + 2, str.tostring(i + 1), text_color = color.gray, text_size = tableSettings.size)
                table.cell(result, 1, i + 2, formatTime(p.point.x, 1), text_color = color.white, text_size = tableSettings.size)
                table.cell(result, 2, i + 2, str.tostring(p.point.y, format.mintick), text_color = color.white, text_size = tableSettings.size)
                table.cell(result, 3, i + 2, p.abbr != "" ? p.abbr : (p.isHigh ? "H" : "L"), text_color = pColor, text_size = tableSettings.size)
                table.cell(result, 4, i + 2, p.isHigh ? "H" : "L", text_color = pColor, text_size = tableSettings.size)
                table.cell(result, 5, i + 2, str.tostring(p.cumulativeVolume, format.volume), text_color = color.white, text_size = tableSettings.size)
                table.cell(result, 6, i + 2, p.closeBreaksPivot ? "Broke" : "─", 
                     text_color = p.closeBreaksPivot ? color.orange : color.gray, text_size = tableSettings.size)
    
    result


// ---------------------------------------------------------------------------------------------------------------------
// USAGE EXAMPLE AREA
// ---------------------------------------------------------------------------------------------------------------------

int iPivotLimit = input.int(1000, "Limit", group = "S O U R C E")
string iSource = input.string("high/low", "Source", options = ["high/low", "custom"], group = "S O U R C E")
float iSourceHigh = input.source(close, "Custom High", group = "S O U R C E")
float iSourceLow = input.source(close, "Custom Low", group = "S O U R C E")

// Input: Outside Candle Handling
string iOutsideBarPriority = input.string("auto", "Priority", options = ["auto", "sentiment", "high", "low"], tooltip = "Determines the priority of the zigzag direction when an Outside (Engulfing) bar occurs.\n\nAuto: Uses Lower Timeframe data. Falls back to Sentiment if no data available.\nSentiment: Uses candle color (Green=Low first, Red=High first).\nHigh/Low: Forces specific direction.", group = "O U T S I D E   B A R S")

// Input: Features 
bool iFeatureCloseBreaksClose = input.bool(true, "Close Breaks Close", tooltip = "When enabled, checks if the closing price of the current pivot breaks the closing price of the previous pivot of the same type (High vs High, Low vs Low).", group = "F E A T U R E S")
bool iFeatureCloseBreaksPivot = input.bool(true, "Close Breaks Pivot", tooltip = "When enabled, checks if the closing price of the current pivot breaks the extreme price (High/Low) of the previous pivot of the same type.", group = "F E A T U R E S")
bool iFeatureIgnoreInsideBars = input.bool(false, "Ignore Inside Bars", tooltip = "If enabled, Inside Bars will not be used to calculate pivots. Breakouts will be compared to the last non-inside candle.", group = "F E A T U R E S")

// Input: Set theming options
bool iThemeHide = input.bool(false, "Hide", group = "T H E M I N G")
bool iThemeShowCloseInfo = input.bool(true, "Show close info", group = "T H E M I N G")
color iThemeColorDefault = input.color(color.rgb(120, 123, 134, 0), "Default", group = "T H E M I N G")
color iThemeColorNeutral = input.color(color.rgb(200, 200, 000, 0), "Neutral", group = "T H E M I N G")
color iThemeColorBullish = input.color(color.rgb(000, 200, 000, 0), "Bullish", group = "T H E M I N G")
color iThemeColorBearish = input.color(color.rgb(200, 000, 000, 0), "Bearish", group = "T H E M I N G")
string iThemeStyle = input.string("labels & lines", "Style", options = ["labels & lines", "labels", "none"], group = "T H E M I N G")
int iThemeLineWidth = input.int(2, "Line width", group = "T H E M I N G")
string iThemeLabelSize = input.string("normal", "Label size", options = ["huge", "large", "normal", "small", "tiny"], group = "T H E M I N G")
bool iThemeShowLabelL = input.bool(true, "Show label L", group = "T H E M I N G")
bool iThemeShowLabelLL = input.bool(true, "Show label LL", group = "T H E M I N G")
bool iThemeShowLabelHL = input.bool(true, "Show label HL", group = "T H E M I N G")
bool iThemeShowLabelH = input.bool(true, "Show label H", group = "T H E M I N G")
bool iThemeShowLabelLH = input.bool(true, "Show label LH", group = "T H E M I N G")
bool iThemeShowLabelHH = input.bool(true, "Show label HH", group = "T H E M I N G")

// Input: Set Tooltip Options
bool iTooltipDisable = input.bool(false, "Disable", group = "T O O L T I P S")
bool iTooltipName = input.bool(true, "Show name", group = "T O O L T I P S")
bool iTooltipPrice = input.bool(true, "Show price", group = "T O O L T I P S")
bool iTooltipClose = input.bool(true, "Show close", group = "T O O L T I P S")
bool iTooltipVolume = input.bool(true, "Show volume", group = "T O O L T I P S")
bool iTooltipCloseBreaksClose = input.bool(true, "Show close breaks close", group = "T O O L T I P S")
bool iTooltipCloseBreaksPivot = input.bool(true, "Show close breaks pivot", group = "T O O L T I P S")

// Logic for Priority Resolution
ltf = getLowerTimeframePeriod() 
[ltf_high, ltf_low] = request.security_lower_tf(syminfo.tickerid, ltf, [iSourceHigh, iSourceLow])

bool ltfAvailable = ltf != timeframe.period
// Determine LTF Direction: if high index <= low index, high came first. Priority = "high".
string ltfDirection = ltf_high.lastindexof(ltf_high.max()) <= ltf_low.lastindexof(ltf_low.min()) ? "high" : "low"
// Determine Sentiment Direction: Green (close >= open) means Low first. Priority = "low".
string sentimentDirection = close >= open ? "low" : "high"

string resolvedPriority = "high" // Default fallback

if iOutsideBarPriority == "high"
    resolvedPriority := "high"
else if iOutsideBarPriority == "low"
    resolvedPriority := "low"
else if iOutsideBarPriority == "sentiment"
    resolvedPriority := sentimentDirection
else if iOutsideBarPriority == "auto"
    if ltfAvailable
        resolvedPriority := ltfDirection
    else
        resolvedPriority := sentimentDirection

Source sourceSettings = Source.new(
  high      = iSource == "high/low" ? high : iSourceHigh, 
  low       = iSource == "high/low" ? low : iSourceLow,
  priority  = resolvedPriority) // Calculated per bar

Features featuresSettings = Features.new(
  closeBreaksClose = iFeatureCloseBreaksClose, 
  closeBreaksPivot = iFeatureCloseBreaksPivot,
  ignoreInsideBars = iFeatureIgnoreInsideBars) 

Theme themeSettings = Theme.new(
  enabled       = not iThemeHide,
  colorDefault  = iThemeColorDefault, 
  colorNeutral  = iThemeStyle == "none" ? iThemeColorDefault : iThemeColorNeutral, 
  colorBullish  = iThemeStyle == "none" ? iThemeColorDefault : iThemeColorBullish, 
  colorBearish  = iThemeStyle == "none" ? iThemeColorDefault : iThemeColorBearish, 
  coloredLines  = iThemeStyle == "labels & lines" ? true : false,
  lineWidth     = iThemeLineWidth,
  labelSize     = iThemeLabelSize,
  showLabelL    = iThemeShowLabelL,
  showLabelHL   = iThemeShowLabelHL,
  showLabelLL   = iThemeShowLabelLL,
  showLabelH    = iThemeShowLabelH,
  showLabelLH   = iThemeShowLabelLH,
  showLabelHH   = iThemeShowLabelHH,
  showCloseInfo = iThemeShowCloseInfo,
  showTooltips  = not iTooltipDisable,
  tooltips      = Tooltips.new(iTooltipName, iTooltipPrice, iTooltipClose, iTooltipVolume, iTooltipCloseBreaksClose, iTooltipCloseBreaksPivot))

settings = Settings.new(sourceSettings, featuresSettings, themeSettings, iPivotLimit)

array<Pivot> pivots = new(settings)


// ---------------------------------------------------------------------------------------------------------------------
// UTILITY FUNCTION EXAMPLES - Using Export Methods
// ---------------------------------------------------------------------------------------------------------------------

// Input: Current Price Line
bool iCurrentLineVisible = input.bool(true, "Show Current Price Line", group = "C U R R E N T   P R I C E")
color iCurrentLineColor = input.color(color.gray, "Line Color", group = "C U R R E N T   P R I C E")
int iCurrentLineWidth = input.int(1, "Line Width", minval = 1, maxval = 4, group = "C U R R E N T   P R I C E")
string iCurrentLineStyle = input.string("Dashed", "Line Style", options = ["Solid", "Dashed", "Dotted"], group = "C U R R E N T   P R I C E")

// Input: Live Pivot Projection
bool iLiveProjectionVisible = input.bool(true, "Show Live Projection", group = "L I V E   P R O J E C T I O N")
int iLiveProjectionOffset = input.int(3, "Offset (bars)", minval = 1, maxval = 20, group = "L I V E   P R O J E C T I O N")
string iLiveProjectionSize = input.string(size.normal, "Size", options = [size.tiny, size.small, size.normal, size.large, size.huge], group = "L I V E   P R O J E C T I O N")

// Input: Live Pivot Table
bool iTableVisible = input.bool(false, "Show Live Pivot Table", group = "L I V E   T A B L E")
string iTablePosition = input.string(position.bottom_right, "Position", options = [position.top_left, position.top_center, position.top_right, position.middle_left, position.middle_center, position.middle_right, position.bottom_left, position.bottom_center, position.bottom_right], group = "L I V E   T A B L E")
string iTableSize = input.string(size.small, "Size", options = [size.auto, size.tiny, size.small, size.normal, size.large, size.huge], group = "L I V E   T A B L E")
int iTableRows = input.int(5, "Rows", minval = 1, maxval = 10, group = "L I V E   T A B L E")
color iTableHeaderBg = input.color(color.rgb(30, 30, 60), "Header Background", group = "L I V E   T A B L E")
color iTableBg = input.color(color.rgb(20, 20, 40, 80), "Table Background", group = "L I V E   T A B L E")

// Input: Debug/Pattern Info
bool iShowSequence = input.bool(false, "Show Pivot Sequence", group = "D E B U G")
bool iDebugLog = input.bool(false, "Enable Debug Logging", group = "D E B U G")
string iPatternToMatch = input.string("", "Pattern to Match (e.g. HH,HL)", group = "D E B U G")


// ---------------------------------------------------------------------------------------------------------------------
// CREATE SETTINGS OBJECTS (using new types)
// ---------------------------------------------------------------------------------------------------------------------

CurrentLineSettings currentLineSettings = CurrentLineSettings.new(
    visible = iCurrentLineVisible,
    clr     = iCurrentLineColor,
    width   = iCurrentLineWidth,
    style   = iCurrentLineStyle)

LivePivotSettings livePivotSettings = LivePivotSettings.new(
    visible   = iLiveProjectionVisible,
    offset    = iLiveProjectionOffset,
    size      = iLiveProjectionSize)

LiveTableSettings liveTableSettings = LiveTableSettings.new(
    visible  = iTableVisible,
    position = iTablePosition,
    size     = iTableSize,
    rows     = iTableRows,
    headerBg = iTableHeaderBg,
    tableBg  = iTableBg)


// ---------------------------------------------------------------------------------------------------------------------
// DRAW VISUALIZATIONS USING EXPORT METHODS
// ---------------------------------------------------------------------------------------------------------------------

// Current Price Line - using export method
var line currentLine = na
currentLine := pivots.drawCurrentPriceLine(currentLineSettings, currentLine)

// Live Pivot Prediction - using export method
var LivePivot livePivot = LivePivot.new()
livePivot := pivots.predictLivePivot(livePivot, high, low, themeSettings, resolvedPriority)
livePivot := pivots.drawLivePivotLabel(livePivot, livePivotSettings)

// Live Pivot Table - using export method
var table pivotTable = na
pivotTable := pivots.drawLivePivotTable(livePivot, liveTableSettings, themeSettings, pivotTable)


// ---------------------------------------------------------------------------------------------------------------------
// DEBUG FEATURES (optional)
// ---------------------------------------------------------------------------------------------------------------------

// Pivot Sequence Display
var label sequenceLabel = na
if barstate.islast and iShowSequence and pivots.size() >= 3
    string sequence = pivots.getSequence(5, livePivot)
    if na(sequenceLabel)
        sequenceLabel := label.new(bar_index, high, "Sequence: " + sequence, style = label.style_label_down, color = color.new(color.blue, 80), textcolor = color.white, size = size.small)
    else
        sequenceLabel.set_xy(bar_index, high)
        sequenceLabel.set_text("Sequence: " + sequence)

// Pattern Matching
var label patternLabel = na
if barstate.islast and iPatternToMatch != "" and pivots.matchesPattern(iPatternToMatch, livePivot)
    Pivot lastPivot = pivots.getLast()
    if not na(lastPivot)
        if na(patternLabel)
            patternLabel := label.new(bar_index - 3, lastPivot.isHigh ? low : high, "Pattern: " + iPatternToMatch, style = lastPivot.isHigh ? label.style_label_up : label.style_label_down, color = color.new(color.green, 70), textcolor = color.white, size = size.normal)
        else
            patternLabel.set_xy(bar_index - 3, lastPivot.isHigh ? low : high)

// Debug Logging
if barstate.islast and iDebugLog and pivots.size() > 0
    Pivot lastPivot = pivots.getLast()
    Pivot dbgLastHigh = pivots.getLastHigh()
    Pivot dbgLastLow = pivots.getLastLow()
    
    log.info("═══════════════════════════════════════")
    log.info("LIVE PIVOT DEBUG")
    log.info("───────────────────────────────────────")
    log.info("Last Pivot: {0} @ {1}", lastPivot.abbr, str.tostring(lastPivot.point.y, format.mintick))
    if not na(dbgLastHigh)
        log.info("Last HIGH: {0} @ {1}", dbgLastHigh.abbr, str.tostring(dbgLastHigh.point.y, format.mintick))
    if not na(dbgLastLow)
        log.info("Last LOW: {0} @ {1}", dbgLastLow.abbr, str.tostring(dbgLastLow.point.y, format.mintick))
    log.info("PREDICTION: {0} @ {1}", livePivot.abbr, str.tostring(livePivot.price, format.mintick))
    if livePivot.isOutsideBar
        log.info("OUTSIDE BAR: {0} → {1}", livePivot.abbr, livePivot.abbr2)
    log.info("═══════════════════════════════════════")